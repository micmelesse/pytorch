// !!! This is a file automatically generated by hipify!!!
#include <ATen/hip/detail/LazyNVRTC.h>

#include <ATen/hip/nvrtc_stub/ATenNVRTC.h>
#include <ATen/DynamicLibrary.h>
#include <stdexcept>

namespace at {
namespace cuda {
namespace detail {
namespace _stubs {

at::DynamicLibrary& getCUDALibrary() {
#if defined(_WIN32)
  static at::DynamicLibrary lib("nvcuda.dll");
#else
  static at::DynamicLibrary lib("libcuda.so.1");
#endif
  return lib;
}

at::DynamicLibrary& getNVRTCLibrary() {
  constexpr auto major = HIP_VERSION / 1000;
  constexpr auto minor = ( HIP_VERSION / 10 ) % 10;
#if defined(_WIN32)
  auto libname = std::string("nvrtc64_") + std::to_string(major) + std::to_string(minor) + "_0.dll";
#else
  static auto libname = std::string("libnvrtc.so.") + std::to_string(major) + "." + std::to_string(minor);
#endif
  static at::DynamicLibrary lib(libname.c_str());
  return lib;
}

#define _STUB_1(LIB, NAME, RETTYPE, ARG1)                                            \
RETTYPE NAME(ARG1 a1) {                                                              \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1);                                                                     \
}

#define _STUB_2(LIB, NAME, RETTYPE, ARG1, ARG2)                                      \
RETTYPE NAME(ARG1 a1, ARG2 a2) {                                                     \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2);                                                                 \
}

#define _STUB_3(LIB, NAME, RETTYPE, ARG1, ARG2, ARG3)                                \
RETTYPE NAME(ARG1 a1, ARG2 a2, ARG3 a3) {                                            \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2, a3);                                                             \
}

#define _STUB_4(LIB, NAME, RETTYPE, ARG1, ARG2, ARG3, ARG4)                          \
RETTYPE NAME(ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4) {                                   \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2, a3, a4);                                                         \
}

#define CUDA_STUB1(NAME, A1) _STUB_1(CUDA, NAME, hipError_t CUDAAPI, A1)
#define CUDA_STUB2(NAME, A1, A2) _STUB_2(CUDA, NAME, hipError_t CUDAAPI, A1, A2)
#define CUDA_STUB3(NAME, A1, A2, A3) _STUB_3(CUDA, NAME, hipError_t CUDAAPI, A1, A2, A3)
#define CUDA_STUB4(NAME, A1, A2, A3, A4) _STUB_4(CUDA, NAME, hipError_t CUDAAPI, A1, A2, A3, A4)

#define NVRTC_STUB1(NAME, A1) _STUB_1(NVRTC, NAME, hiprtcResult, A1)
#define NVRTC_STUB2(NAME, A1, A2) _STUB_2(NVRTC, NAME, hiprtcResult, A1, A2)
#define NVRTC_STUB3(NAME, A1, A2, A3) _STUB_3(NVRTC, NAME, hiprtcResult, A1, A2, A3)

NVRTC_STUB2(hiprtcVersion, int*, int*);
NVRTC_STUB2(hiprtcAddNameExpression, hiprtcProgram, const char * const);

hiprtcResult hiprtcCreateProgram(hiprtcProgram *prog,
                               const char *src,
                               const char *name,
                               int numHeaders,
                               const char * const *headers,
                               const char * const *includeNames) {
  auto fn = reinterpret_cast<decltype(&hiprtcCreateProgram)>(getNVRTCLibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hiprtcCreateProgram");
  lazyNVRTC.hiprtcCreateProgram = fn;
  return fn(prog, src, name, numHeaders, headers, includeNames);
}

NVRTC_STUB1(hiprtcDestroyProgram, hiprtcProgram *);
NVRTC_STUB2(hiprtcGetCodeSize, hiprtcProgram, size_t *);
NVRTC_STUB2(hiprtcGetCode, hiprtcProgram, char *);
#if HIP_VERSION >= 11010
NVRTC_STUB2(nvrtcGetCUBINSize, hiprtcProgram, size_t *);
NVRTC_STUB2(nvrtcGetCUBIN, hiprtcProgram, char *);
#endif
NVRTC_STUB3(hiprtcCompileProgram, hiprtcProgram, int, const char * const *);
_STUB_1(NVRTC, hiprtcGetErrorString, const char *, hiprtcResult);
NVRTC_STUB2(hiprtcGetProgramLogSize,hiprtcProgram, size_t*);
NVRTC_STUB2(hiprtcGetProgramLog, hiprtcProgram, char *);
NVRTC_STUB3(hiprtcGetLoweredName, hiprtcProgram, const char *, const char **);

CUDA_STUB2(hipModuleLoadData, hipModule_t *, const void *);
CUDA_STUB3(hipModuleGetFunction, hipFunction_t *, hipModule_t, const char *);
CUDA_STUB4(hipModuleOccupancyMaxActiveBlocksPerMultiprocessor, int *, hipFunction_t, int, size_t);
CUDA_STUB2(hipGetErrorString___, hipError_t, const char **);
CUDA_STUB1(hipCtxGetCurrent, hipCtx_t *);
CUDA_STUB1(hipModuleUnload, hipModule_t);
CUDA_STUB3(hipDevicePrimaryCtxGetState, hipDevice_t, unsigned int *, int *);
CUDA_STUB4(hipLinkCreate, unsigned int, hipJitOption *, void **, CUlinkState *);
CUDA_STUB3(hipLinkComplete, CUlinkState, void **, size_t *);

// Irregularly shaped functions
hipError_t CUDAAPI hipModuleLaunchKernel(hipFunction_t f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                hipStream_t hStream,
                                void **kernelParams,
                                void **extra) {
  auto fn = reinterpret_cast<decltype(&hipModuleLaunchKernel)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipModuleLaunchKernel");
  lazyNVRTC.hipModuleLaunchKernel = fn;
  return fn(f,
            gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ,
            sharedMemBytes, hStream, kernelParams, extra);
}

hipError_t CUDAAPI hipModuleLoadDataEx(hipModule_t *module,
                                    const void *image,
                                    unsigned int numOptions,
                                    hipJitOption *options,
                                    void **optionValues) {
  auto fn = reinterpret_cast<decltype(&hipModuleLoadDataEx)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipModuleLoadDataEx");
  lazyNVRTC.hipModuleLoadDataEx = fn;
  return fn(module, image, numOptions, options, optionValues);
}

hipError_t CUDAAPI
hipLinkAddData(CUlinkState state,
              hipJitInputType type,
              void *data,
              size_t size,
              const char *name,
              unsigned int numOptions,
              hipJitOption *options,
              void **optionValues) {
  auto fn = reinterpret_cast<decltype(&hipLinkAddData)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipLinkAddData");
  lazyNVRTC.hipLinkAddData = fn;
  return fn(state, type, data, size, name, numOptions, options, optionValues);
}

} // namespace _stubs

NVRTC lazyNVRTC = {
#define _REFERENCE_MEMBER(name) _stubs::name,
  AT_FORALL_NVRTC(_REFERENCE_MEMBER)
#undef _REFERENCE_MEMBER
};
} // namespace detail
} // namespace cuda
} // namespace at
